# 기본 데이터 구조



### **Linked List**

&#x20;링크드리스트는 대표적인 데이터의 선형 집합입니다. 선형이라는 의미를 유추해볼 때, 순서를 표현하는 노드로 구성되어 있음을 짐작할 수 있습니다. 여기서에서 노드는 순서에 대한 정보를 가지기 위한 레퍼런스 그리고 값을 포함하고 있습니다. 링크드리스트의 논리적 저장순서는 메모리의 물리적 저장순서와 일치하지않습니다.&#x20;

&#x20;즉 물리적으로 연결되어 있지 않기 때문에 여기저기 흩어져 각 노드에 대한 정보를 메모리에 저장합니다. 이 리스트는 기본적으로 처음과 끝을 가리키는 head와 tail정보를 가지고 있습니다. 링크드리스트의 각 노드에 접근하기 위해서는 head에 레퍼런스가 절대적으로 필요합니다. 따라서 빠르게 접근(탐색)하는 것이 불가능합니다. 배열보다는 캐시지역성이 떨어진다고 말할 수 있습니다.

&#x20;만약 배열처럼 고정된 크기의 메모리를 사용하여 삽입이 일어났을 경우, 메모리를 한칸씩 뒤로 옴기는 로직이 수행되기때문에 비효율적으로 동작하게되는데요. 링크드리스트는 각 노드의 위치를 연결하는 선형 구조 덕분에 메모리를 동적으로 사용할 수 있어 효율적인 삽입/삭제가 가능하다는 것이 장점입니다. 하지만 다음 노드에 대한 포인터 정보를 가지고 있기 때문에 추가적인 메모리가 필요하다는 점을 기억해야합니다. 또한 선형이라는 특성으로 빠른 접근이 불가능한 점 그리고 병렬적인 작업 수행도 할 수 없다는 것이 단점입니다.

{% hint style="success" %}
_\*Tip_

_이미지를 연상하면서 구현한다._

_class Node는 next , value property 를 포함한다._

_class LinkedList는 head, tail, total 값을 포함한다._

_마지막으로 각 함수를 구현할 때, head와 tail이 초기에는 null값이라는 것을 기억하고 리스트가 비어있는 경우도 꼭 고려한다._

__

_\*구현해보기_

* _prepend_
* _insert_
* _delete_
* _deleteHead_
* _deleteTail_
* _reverse_
* _toString_
* _toArray_
* _length_
{% endhint %}

\


### **Queue**

&#x20;큐는 순차적인 특성을 가진 컬렉션입니다. 순차적이라는 의미는 순서에 영향을 받는다고 생각할 수 있습니다. 큐 내부의 엔티티들은 차례대로 순서를 유지하는데, 특별한 점은 삽입,삭제의 동작과정에서 가장 뒷 부분에 엔티티를 추가하고 가장 앞부분의 엔티티를 제거합니다.&#x20;

&#x20;이 특성을 선입선출(First In First Out : FIFO)라고 합니다. 이러한 표현은 선입선처리 행위에 따라 순서대로 처리함으로써 기술을 처리하거나 수요 충돌을 관리하는 대기의 원칙을 말합니다. 다시말해, 먼저 온 것은 먼저 처리되고, 처리가 끝날 때까지 다음 것은 대기 상태에 놓이게 됩니다. 새로운 요소를 추가했는데 제거를 하고 싶다면 이전에 추가되었던 모든 요소들을 제거해야겠네요 :(

{% hint style="success" %}
_\*Tip_

_링크드리스트의 선형구조를 사용한다._

__

_\*구현해보기_

* _enqueue (= .apend)_
* _dequeue (= .deleteHead)_
{% endhint %}

\


### **Stack**

스택은 이전에 다뤘던 큐와 마찬가지로 추상 데이터 타입입니다. 또한 2가지 연산을 통해 요소를 추가하고 제거할 수 있습니다. 하지만 반대로 후입선출(Last In First Out : LIFO)이라는 특성을 가진 구조입니다. 예를 들어, 쌓여있는 물건 중에서 원하는 것을 꺼내려면 어떻게 해야할까요? 위에 있는 물건을 차례대로 꺼내야겠지요. 맞습니다! 스택이라는 자료구조의 이름은 실생활으로 모습으로부터 유래되었습니다. 제일 먼저 추가한 요소를 제거하고 싶다면 최근에 넣었던 모든 요소를 순차적으로 제거 해야합니다.

{% hint style="success" %}
_\*Tip_

_링크드리스트의 선형구조를 사용한다._

__\
_\*구현해보기_&#x20;

* _push (= .prepend)_
* _pop (= .deleteHead)_
{% endhint %}

\


### **Hash table**

&#x20;해시테이블은 Key - Value 묶음을 가진 시스템입니다. 앞서 언급했듯이 배열은 선형 탐색으로 각 요소에 접근 할 수 할 수 있습니다. 하지만 요소가 많을 수록 시간이 오래 걸린다는 단점을 가지고 있습니다. 하나씩 일일히 체크해야하니까요(\*big-O(n)). 헤시테이블의 경우, 상수에 시간으로 원하는 값을 검색하여 엄청나게 빠른 속도로 삽입/삭제 동작을 수행합니다. 놀라운 것은 이 테시테이블의 내부 자료구조는 배열입니다.&#x20;

&#x20;배열을 사용함에도 불구하고 이렇게 빠른 동작이 가능한 이유는 바로 Hash Function의 알고리즘 덕분입니다. 이 함수의 기능은 Key갑을 index로 변환하는 로직, 즉 순서대로 데이터를 저장하는 것이 아니라 저장할 위치를 Key값을 통해 미리 변환하고 데이터를 맵핑해놓을 수 있게 합니다.&#x20;

&#x20;해시테이블을 구현할 때, 데이터의 충돌에 대해 염두해두어야합니다. 해시테이블의 값은 Hash Function으로 변환된 index 위치에 저장된다고 하였습니다. 이는 각각의 Key가 유일한 값이 되어야 한다는 것을 의미합니다. 예를 들면, hash(key1) , hash(key2)가 로직에 의해서 동일하게 index 5의 위치를 반환한다고 가정하였을 때, 배열\[5]의 값은 무엇이 되어야할 까요? 무엇이 나오게 할지는 내부 구현에 따라서 다를 것입니다. 하지만 우리는 저장한 모든 값을 기억하는 테이블을 구현하는 것이 목적이니 충돌로 인해 데이터가 손실되서는 안될 것입니다. 어떻게 해결할지 한번 생각해봅시다:)&#x20;

&#x20;동일한 index를 가진 키값을 모두 기억하기 위해서 배열의 각 요소를 리스트 자료형으로 만들면 충돌을 해결할 수 있습니다. 이 방법을 사용하여 리스트에 접근할 때 선형탐색을 수행하기 때문에 시간복잡도가 상수를 벗어나 느려질 수 있지만, 중요한 것은 이렇게 아주 기본적인 자료구조 두가지를 활용하여 해시테이블이라는 멋진 시스템을 구현할 수 있게 되었습니다. 사실 각 프로그래밍 언어에서는 내부적으로 훨씬 더 세련된 알고리즘으로 해시테이블을 사용하고 있어서 따로 구현할 필요가 없습니다. 자바스크립트의 객체, 파이썬의 딕셔너리가 그 예입니다.&#x20;

&#x20;ES6이후 다른 프로그래밍 언어에서 사용되던 해시테이블 종류인 Map, Set이 자바스크립트에 추가되었습니다. 자바스크립트에서 객체는 Key는 문자열만 허용되는 반면, Map은 숫자, 배열 심지어 함수타입으로도 설정할 수 있습니다. 또한 정렬과 같은 기존 객체에서 할수 없는 기능을 가지고 있습니다. Set은 Map과 유사하지만 중복된 값은 무시하고 메모리 Key만 저장한다는 것이 특징입니다. &#x20;

{% hint style="success" %}
_\*Tip_

_배열은 고정된 사이즈를 가지고 있고 각 요소는 LinkedList의 구조를 가진다._

_hash함수에서 반환되는 index 값은 배열의 고정된 사이즈 범위에 포함되어야만 한다._&#x20;

__\
_\*구현해보기_

* _set_
* _delete_
* _get_
* _has_
* _getKeys_
* _getValues_
{% endhint %}

\


### **Heap**

힙은 속성을 가진 트리기반 데이터 구조입니다. 여기서 말하는 속성은 데이터를 어떤 방식으로 완전이진트리에 위치시킬 것인지를 결정합니다. 부모노드의 키값이 자식노드의 키값보다 항상 크게 구성하는 힙을 최대힙, 반대의 경우를 최소힙이라고 합니다. 대소관계의 성립은 부모와 자식사이에서만 성립하고 자식간에 크기는 비교하지 않는 것이 특징입니다. 또 가장 높거나 낮은 우선순위를 가지는 노드가 항상 뿌리노드에 오게 되는 특징이 있어서 이를 우선순위 큐와 같은 추상자료형으로 구현할 수 있습니다. 이러한 특징을 가진 힙은 최댓값 및 최솟값을 빠르게 찾아내기 위해 고안되었습니다.

* 완전 __ 이진 __ 트리 _: binary tree_라고 __ 불리며 __ 자식노드의 __ 수가 __ 최대 _2_개인 __ 트리를 __ 말합니다_._
* 최대힙 _:_ 현재 __ 데이터 __ 집합에서 __ 루트가 __ 가장 __ 큰 __ 것을 __ 말합니다_. (_밑으로 __ 갈수록 __ 점점 __ 값이 __ 작아짐_)_
* 최소힙 _:_ 현재 __ 데이터 __ 집합에서 __ 루트가 __ 가장 __ 작은 __ 것을 __ 말합니다_. (_밑으로 __ 갈수록 __ 점점 __ 값이 __ 커짐_)_

{% hint style="success" %}
_\*Tip_

_최대힙은 부모 노드의 값은 자식노드의 값보다 크거나 같다._

_최소힙은 부모 노드의 값은 자식노드의 값보다 작거나 같다._

_이를 보아, 중복된 값을 허용할 수 있다._

_왼쪽 자식 index = (부모 index) \* 2_

_오른쪽 자식 index = (부모 index)\*2 +1_

_부모인덱스 = 자식 index / 2_
{% endhint %}

