# 220619 Nest



### Nest

시스템 디자인 측면에서의 지원이 있는 백엔드 어플리케이션 프레임 워크입니다. 타입스크립트를 네이티브로 지원하고 있어 데코레이터 클래스를 통해 다양한 기능들을 정형화/구조화하여 설계구현할 수 있습니다. NestJs에서는 Singleton 패턴을 지향하기 때문에 인스턴스를 직접 생성하지 않고 모듈을 통해 Injection 하는 패턴을 권장하고 있습니다.

싱글톤 패턴은 객체의 인스턴스가 오직 한개만 생성되는 패턴입니다. 이 패턴을 사용하면 고정된 메모리 영역을 사용하기 때문에 추후 객체에 접근할 때 메모리 낭비를 방지 할 수 있습니다. 뿐만아니라 생성된 인스턴스를 활용하니 속도측면에서도 이점이 있습니다. 또한 다른 클래스간에 데이터 공유가 쉽습니다. 싱글톤 인스턴스가 전역으로 사용되는 인스턴스이기 때문에 다른 클래스의 인스턴스들이 접근하여 사용할 수 있습니다. 하지만 여러 클래스에서 해당 인스턴스에 동시에 접근하게 되면 동시성 문제가 발생할 수 있으니 이점을 유의해서 설계하는 것이 좋습니다.

효율에서의 이점을 얻을 수 있지만 다양한 문제점을 수반하기 때문에 trade-off를 잘 고려해야합니다. 먼저 싱글톤 패턴을 구현하는 코드 자체가 많이 필요합니다. 멀티스레딩 환경에서 발생할 수 있는 동시성 문제 해결을 위해 syncronized 키워드를 사용해야합니다. 두 번째는 테스트하기 어렵습니다. 싱글톤 인스턴스는 자원을 공유하고 있기 때문에 테스트가 격리된 환경에서 수행되려면 매번 인스턴스의 상태를 초기화시켜주어야 합니다. 셋 째, 클라이언트가 클래스에 의존하게 됩니다. 클래스 안에서 객체를 생성하고 있으므로 이는 SOLID원칙 중 DIP를 위반하게 되고 OCP원칙 또한 위반할 가능성이 높습니다.

비록 싱글톤패턴은 안티패턴으로 불릴 만큼 단독으로 사용한다면 객체지향에 위반되는 사례가 많습니다. 하지만 프레임워크의 도움을 받으면 싱글톤 패턴의 문제점들을 보완하면서 장점의 혜택을 누릴 수 있습니다.



### Scheme

단어는 모양을 뜻하는 그리어에서 유래되었습니다. 문맥에 따라 의미가 달라 질 수 있습니다. 예를 들어, 심리학에서는 정신 건강의학에서 인지행동 치료시 적용할 수 있는 스키마 이론이라는 개념으로 컴퓨터 과학에서 말하는 데이터 베이스 기반에 대한 스키마와 의미가 달라질 수 있다는 점을 인지해야합니다.

컴퓨터 데이터 베이스에서의 스키마는 데이터베이스의 설계 또는 구조를 의미합니다. 논리적으로 볼수 있는 일종의 골격 구조로서 엔티티, 속성, 관계 및 데이터 조작시 데이터 값들이 갖는 제약 조건에 대하여 전체적으로 정의한 것입니다. 쉽게 말해, 지도나 명세서와 같은 것입니다.



### Entity

데이터베이스에 저장되는 데이터의 유형를 보여주는 모델과 같은 것입니다. 저장되고 관리되는 데이터의 집합(객체)을 의미합니다. 데이터의 가장 작은 논리적 단위를 에트리뷰터라 하고 각 속성은 모델의 특성이나 상태를 기술합니다.



### Data Transfer Operation(DTO)

계층간 데이터 교환을 위해 사용하는 객체입니다. 객체를 담은 데이터를 직접 보낼 수 있지만 민감한 비지니스 기능이 노출될 수 있고 계층간 의존성이 생길 수 있습니다. 따라서 DTO를 사용하여 서로의 의존성을 낮추고 독립적인 개발을 가능하게 합니다. 데이터 모델의 커스텀 타입으로서 정의하여 사용할 수 있습니다.



### @Decorator

데코레이터는 클래스 선언, 메서드, 접근자, 프로퍼티 또는 매개변수에 첨부할 수 있는 특수한 종류의 선언입니다. 데코레이팅 된 선언에 대한 정보와 함께 런타임에 호출되는 함수여야합니다.



### ValidationPipe

nest는 잘못된 요청을 쉽게 검증할 수 있는 툴(모듈)을 제공합니다. class-validator을 통해 데코레이터 형태로 클래스를 편하고 강력하게 validation을 할 수 있고 Joi라는 라이브러리를 이용해 스키마 기반의 밸리데이션을 할 수 있게 합니다. 전역으로 선언할 시, 모듈 컨텍스트 외부에서 바인딩 되었으므로 종속성을 주입해야하기 때문에 모듈에 추가하는 작업이 필요합니다.



### Object Relational Mapping(ORM)

객체는 클래스를 이용하고 관계형 데이터 베이스는 테이블을 사용하여 모델간에 불일치가 존재합니다. 이 ORM을 사용하면 객체 모델 - 관계형 모델 간의 관계를 바탕으로 SQL을 자동으로 생성하여 불일치를 해결합니다. sql문 대신 코드를 사용하여 간접적으로 데이터베이스 데이터를 다룰 수 있습니다.



### dotenv

개발환경에서는 development, production, testing에 따라 다른 실행을 할 수 있어야합니다. 현재 환경에 맞는 프로그램 실행결과를 도출하기 위해서 다른 접근이 필요합니다. dotenv를 사용하면 process.env를 통하여 환경 설정 변수를 이용할 수 있습니다.



### Active Record vs Data Mapper

둘은 데이터베이스와 상호작용하는 패턴입니다. Data Mapper 레포지토리를 생성하는데 이름을 추상화해서 사용한다는점이 다릅니다. 이러한 이유에서 Active Record보다 대규모 어플리케이션에서 사용하기 좋습니다. Nest에서 지원하는 편리한 Repository모듈이 있기때문에 Data Mapper를 사용하면 앱 전반에서 유용하게 사용할 수 있습니다. 또한 테스트할 때도 사용할 수 있어 유닛 테스트시에도 DB를 사용할 수 있습니다.



### TypeORM create vs save?

Create는 단순히 DB에 들어갈 수 있는 인스턴스를 생성할 뿐이고 DB에 생성, 저장, 업데이트하기 위해서는 Save를 실행하여야합니다. 주의해야할 사항은 이러한 특성으로 entity에 선언한 훅(이벤트맵핑 데코레이터)에 트리커 포인트가 될 수 있습니다. 비동기적 리턴을 반환하는 경우, promise의 경우 꼭 타입에 명시해주어야합니다.



### Map type

네스트에서 클래스를 원하는 방식으로 상속하는 방법입니다. 이 맵타입을 사용하면 오직 InputType만 사용할 수 있습니다. 만약 ObjectType의 entity를 상속하길 원한다면 isAbstract를 통해 확장할 수 있습니다.



### nullable vs defaultValue

해당 값을 입력하지 않으면 값을 없는채로 통과하거나 값을 지정하여 그 값을 담거나 할 수 있습니다.



### Enum

만약 타입이 몇 케이스로 정해져 있다면 string같은 타입보다 구체적인 타입리스트를 열거형으로 정해주는 것이 훨씬 명확한 방법입니다. Enum은 기본적으로 number맵핑이지만 string맵핑으로 구현하면 실제 데이터에 number가 들어가지 않아서 데이터를 명확하게 읽을 수 있습니다.

```
export enum Role {
    ADMIN = 'Admin'
    GENERAL = 'General'
}
```



### Type

리터럴 타입을 정의합니다.

```
export type TRole = "Admin" | "General"
```



### Interface

객체 타입을 정의합니다.

```
export interface IUser {
    name : string;
    age : number;
    roloe: TRole;
}
```



### npm @type/\<package>

자바스크립트로 작성된 모듈을 타입스크립트 환경에서 사용하기 위해서는 타입 데피니션이 필요합니다.



### save—dev

development 환경일 때만 의존성을 같는 모듈을 설치할 때 사용하는 옵션입니다. 실질적으로 동작(production build)할 때 필요하지 않는 패키지를 설치할 때 사용할 수 있습니다.



### Static module vs Dynamic module

다이나믹 모듈은 외부의 설정을 통해 생성되는 정적 모듈입니다. .forRoot({})를 통해 해당 모듈을 설정할 수 있습니다.



### @inject("VarName") vs @injectRepository(Model)

의존성을 주입하는 데코레이터입니다. DB를 사용하는 것이냐 안하는 것이냐의 차이점이 있습니다.



### @Global()

모듈간 export import 작업을 일일해 해줄 필요 없이 전역 모듈로 선언하는 데코레이터입니다.

middleware, pipe line과 같은 전역 기능이 필요할 때, App Module에 선언하는 방법과 botstrap함수에 선언하는 방법이 있습니다. App Module과 의존성을 갖는 모듈들은 앱이 시작할 때 모두 실행됩니다.



### Apollo server Context?

컨텍스트는 매 요청(객체)에 대한 프로퍼티를 사용하여 동작하는 함수를 말합니다. 리졸버에서 사용가능합니다.



### Authentication vs Authorization

누가 자원을 요청하는지 확인하는 과정 ex) 신원 확인(인증)

해당 유저가 permission을 가지고 있는지 확인하는 과정 ex) 권한 확인(인가)

예를 들어, token발급 절차는 인증과 관련있는 로직이고, @useGuards()는 Nest에서 리소스 접근에 권한을 확인하는 역할을 합니다..



### class private function()

외부에 노출되지 않아도 되는 로직을 구현하는 함수입니다.
