# 220623 for dementor



### DI(Dependency Injection)

의존성이란 하나의 객체에서 다른 객체를 가져다 사용하는 것을 의미합니다. 이렇게 의존성이 엮이게 되면 객체의 변경이 이뤄질때, 파쇄효과가 나타나게됩니다. 의존성이 있을 때 의존하는 객체에 변경이 생기거나 다른 객체를 사용해야하는 경우에는 관련된 코드를 전부 변경해야합니다. 이처럼 기존 로직에 새로운 값이 추가되거나 변경될 때 코드 수정이 많은 코드는 확장성이 적은 코드라 말합니다.

객체간의 의존성이 강하기 때문에 결합도가 높은 코드라고 합니다. 쓸대 없이 테스트 코드가 길어진다는 단점도 있습니다. **의존 관계 문제를 해결하면서 코드량을 줄이기 위해서는 인터페이스로 그것의 구현체를 만드는 것입니다.**

내부에서 의존 관계를 끊고 외부에서 객체를 전달 받고, 이 객체의 인터페이스를 정의하여 이 문제를 해결합니다. 결합도를 느슨하게 만들며 확장성 높은 코드를 만들 수 있습니다.

하지만 이 방법은 확장성이 높지만, 제공하는 기능이 많을 경우 모든 각 클래스에 작성해야하는 코드가 많아진다는 단점이 있습니다. 클린코드에서는 추상화의 성격에 따라 적절하게 할것을 언급하였습니다.

주의할 점은 단순히 외부에서 객체를 전달받는 것을 의존성 주입이라고 말하지 않는다는 점입니다. 의존성 주입을 제대로 하기 위해서는 추상화가 된 객체를 외부에서 받도록해야합니다. 추상화, 동일한 특징을 지닌 것을 토대로 코드가 작성되어지기 때문에 각자 다른 클래스로부터의 객체를 주입받는 것은 객체를 안에서 선언하는 것과 동일한 문제를 발생시킬 수 있습니다.

객체를 직접 생성하는 것이 아니라 외부에서 객체를 전달받아 주입받음으로서 객체간의 결합도를 줄이고 유연한 코드를 만드는 방식을 의존성 주입이라고 합니다.





### **IOC(Inversion of Control)**

제어의 역전이란 객체의 생성부터 소멸까지 어플리케이션이 제어권을 갖는 것이 아니라 이런 것을 관리해주는 컨테이너에게 넘기는 것을 말합니다. 즉, 개발자가 열심히 객체를 생성하고, 의존성을 맺어주는 귀찮은 작업들을 컨테이너가 대신해주는 것입니다.

이 경우, 개발자들은 객체 관리할 시간에 다른 작업들에 힘을 쏟을 수 있고, 코드에 재사용성과 유지보수성을 높여주기 때문에 편하게 개발을 할 수 있습니다.

네스트 프레임워크에도 컨테이너가 있습니다. 예를 들면 @Injectable 데코레이터를 사용하면 해당 클래스가 Provider로 사용될 것임을 Nest에게 알려줌으로서 Nest js IOC 컨테이너에서 관리할 수 있게 해줍니다. 그리하여 이 데코레이터로 만들어진 클래스는 기본적으로 Nest js 실행시 싱글턴 객체로 메모리에 존재하게 됩니다.





### **Extends vs Implements ( about Inheritance )**

상속과 인터페이스는 계층화를 위해 사용됩니다. 상속의 형태 중 extends는 상위 클래스의 변수 또는 메소드를 그대로 사용하는 방식이고 implements는 정의된 타입대로 구현을 해야하는 방식입니다. 즉, overriding을 하느냐 안하느냐로 나눌 수도 있습니다.

{% hint style="info" %}
_overloading : 고유한 이름의 함수를 다양한 기능으로 정의하는 것_
{% endhint %}
